<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Key Ng√†y H√¥m Nay L√†</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f9f5f3;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .loading-container {
            text-align: center;
            padding: 20px;
            border: 2px solid #ef8682;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            background-color: #fff;
            width: 80vw;
            max-width: 420px;
        }
        h1 { color: #03fcec; font-size: 28px; margin-bottom: 12px; }
        .key-label { font-size: 14px; color: #888; margin-bottom: 5px; }
        .key-container { display:flex; flex-direction:column; align-items:center; }
        input {
            text-align:center; width:80%; padding:12px; margin-bottom:12px;
            border:2px solid #fc0303; border-radius:8px; font-size:16px;
            background:#f8f8f8; font-weight:bold;
        }
        .button-group { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
        button {
            background-color:#ef8682; color:#fff; padding:12px 18px; border:none;
            border-radius:8px; cursor:pointer; font-size:15px; min-width:140px;
        }
        button:hover { background-color:#e9514d; }
        .footer { text-align:center; margin-top:16px; color:#555; font-size:14px; }
        #player { display:none; } /* youtube player hidden */
    </style>
</head>
<body>
    <!-- Hidden container for YouTube player (kept hidden) -->
    <div id="player"></div>

    <div class="loading-container">
        <h1>üîë KEY C·ª¶A B·∫†N L√Ä</h1>
        <div class="key-label">(Key t·ª± ƒë·ªông t·∫°o ho·∫∑c l·∫•y t·ª´ tham s·ªë ma)</div>

        <div class="key-container">
            <input type="text" id="keyInput" readonly />
            <div class="button-group">
                <button id="copyButton">üìã Copy Key</button>
                <button id="musicButton">‚ñ∂Ô∏è Play Music</button>
            </div>
        </div>

        <div id="dateDisplay" style="margin-top:10px; font-size:18px; color:#555;"></div>
        <div class="footer">
            <b>Copyright By
                <a href="https://zalo.me/0822771058" style="color:#ef8682; text-decoration:none;">Nguy·ªÖn Duy Kh√°nh</a>
                | Time: <span id="clock"></span>
            </b>
        </div>
    </div>

<script>
/* ==== Safe key gen + localStorage handling ====
   - Format: PHONG-TUS- + 16 k√Ω t·ª± [A-Z0-9]
   - If ?ma present -> show it (only if valid format), else generate unique random key
   - Saves used keys in localStorage 'usedKeys' (array)
   - Updates URL with ?ma=KEY using history.replaceState
   - Exposes small helpers on window.__KEY_UTILS
=============================================*/
(function(){
  const PREFIX = "PHONG-TUS-";
  const RANDOM_LEN = 16;
  const CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

  function generateRandomKey() {
    let p = "";
    for (let i = 0; i < RANDOM_LEN; i++) {
      p += CHARS.charAt(Math.floor(Math.random() * CHARS.length));
    }
    return PREFIX + p;
  }

  function _loadUsed() {
    try {
      const raw = localStorage.getItem("usedKeys");
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    } catch (e) {
      return [];
    }
  }

  function _saveUsed(arr) {
    try {
      localStorage.setItem("usedKeys", JSON.stringify(arr));
    } catch (e) {
      // ignore quota errors
    }
  }

  function markKeyAsUsed(key){
    if (!key) return;
    const used = _loadUsed();
    if (!used.includes(key)) {
      used.push(key);
      _saveUsed(used);
    }
  }

  function isKeyUsed(key){
    if (!key) return false;
    const used = _loadUsed();
    return used.includes(key);
  }

  function generateUniqueKey(maxAttempts = 100) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const k = generateRandomKey();
      if (!isKeyUsed(k)) {
        // mark immediately to reduce duplicate generations
        markKeyAsUsed(k);
        return k;
      }
    }
    // fallback if exhausted: generate and mark (rare)
    const fallback = generateRandomKey();
    markKeyAsUsed(fallback);
    return fallback;
  }

  // expose helpers (non-intrusive)
  window.__KEY_UTILS = {
    generateRandomKey,
    generateUniqueKey,
    markKeyAsUsed,
    isKeyUsed
  };

  function getParam(name) {
    try {
      const u = new URL(window.location.href);
      return u.searchParams.get(name);
    } catch (e) {
      const m = window.location.search.match(new RegExp('[?&]' + name + '=([^&]+)'));
      return m ? decodeURIComponent(m[1]) : null;
    }
  }

  // decide final key: prefer valid ?ma param, otherwise generate unique
  const keyInput = document.getElementById('keyInput');
  let keyFromUrl = getParam('ma');
  function isValidFormat(k) {
    return typeof k === "string" && k.startsWith(PREFIX) && k.length === (PREFIX.length + RANDOM_LEN);
  }

  let finalKey;
  if (isValidFormat(keyFromUrl)) {
    finalKey = keyFromUrl.trim();
    // mark it used (optional) - comment out if you don't want to mark keys from URL
    markKeyAsUsed(finalKey);
  } else {
    finalKey = generateUniqueKey();
    // update URL without reload for easy copying / verification
    try {
      const newUrl = window.location.origin + window.location.pathname + "?ma=" + encodeURIComponent(finalKey);
      history.replaceState({}, "", newUrl);
    } catch (e) { /* ignore */ }
  }

  // display finalKey
  if (keyInput) keyInput.value = finalKey;

  // copy helper (used by button)
  function fallbackCopy(text) {
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.setAttribute("readonly", "");
    ta.style.position = "absolute";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    try { document.execCommand("copy"); alert("Copied: " + text); }
    catch(e) { prompt("Copy the key manually:", text); }
    document.body.removeChild(ta);
  }

  function copyText(t){
    if (!t) return;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(t).then(()=> {
        // optional toast: using alert for simplicity
        // alert("Copied: " + t);
      }).catch(()=> fallbackCopy(t));
    } else fallbackCopy(t);
  }

  // If other code expects handleQueryParams/getkey, keep compatible:
  window.handleQueryParams = function(){
    const params = new URLSearchParams(window.location.search);
    const getkey = params.get('getkey');
    if (getkey === '1') {
      const newKey = generateUniqueKey();
      if (keyInput) keyInput.value = newKey;
      markKeyAsUsed(newKey);
      try {
        const newUrl = window.location.origin + window.location.pathname + "?ma=" + encodeURIComponent(newKey);
        history.replaceState({}, "", newUrl);
      } catch(e){}
    } else {
      // nothing to do: finalKey already set above
    }
  };

  // wire copy button if exists
  const copyBtn = document.getElementById('copyButton');
  if (copyBtn) {
    copyBtn.addEventListener('click', async function(){
      await copyText(finalKey);
      // small UI feedback
      const originalText = copyBtn.textContent;
      copyBtn.textContent = '‚úÖ ƒê√£ copy!';
      setTimeout(()=> copyBtn.textContent = originalText, 1800);
      // mark used on copy
      markKeyAsUsed(finalKey);
    });
  }

})();
</script>

<script>
/* ---------- Time display ---------- */
function updateTime(){
    const now = new Date();
    const hh = String(now.getHours()).padStart(2,'0');
    const mm = String(now.getMinutes()).padStart(2,'0');
    const ss = String(now.getSeconds()).padStart(2,'0');
    const d = now.getDate(), m = now.getMonth()+1, y = now.getFullYear();
    document.getElementById('clock').textContent = `${hh}:${mm}:${ss}`;
    document.getElementById('dateDisplay').textContent = `H√¥m nay l√† ng√†y ${d}/${m}/${y}`;
    document.title = `Key Ng√†y ${d}/${m}/${y} L√†`;
    setTimeout(updateTime, 1000);
}

/* ---------- YouTube Player API integration ---------- */
/* S·ª≠ d·ª•ng video ID t·ª´ YouTube link b·∫°n g·ª≠i: UKox4YEvLpg */
let ytPlayer;
let ytPlayerReady = false;
let ytPlayerInitializing = false;
let playWhenReady = false;
const YT_VIDEO_ID = 'UKox4YEvLpg'; // ƒë·ªïi n·∫øu c·∫ßn
// t·∫£i API
function initYouTubePlayer(){
    if (ytPlayerInitializing || typeof YT !== 'undefined' && ytPlayer) return;
    ytPlayerInitializing = true;
    // inject YT iframe api script if not present
    if (!document.getElementById('yt-iframe-api')) {
        const tag = document.createElement('script');
        tag.id = 'yt-iframe-api';
        tag.src = "https://www.youtube.com/iframe_api";
        document.head.appendChild(tag);
    }
    // onYouTubeIframeAPIReady s·∫Ω ƒë∆∞·ª£c g·ªçi b·ªüi API khi script load
}

// API callback (YouTube y√™u c·∫ßu h√†m to√†n c·ª•c)
function onYouTubeIframeAPIReady(){
    ytPlayer = new YT.Player('player', {
        height: '0',
        width: '0',
        videoId: YT_VIDEO_ID,
        playerVars: {
            autoplay: 0,
            controls: 0,
            rel: 0,
            modestbranding: 1,
            playsinline: 1
        },
        events: {
            'onReady': function(e){
                ytPlayerReady = true;
                ytPlayerInitializing = false;
                try { ytPlayer.setVolume(60); } catch(e){}
                if (playWhenReady) {
                    ytPlayer.seekTo(0);
                    ytPlayer.playVideo();
                    playWhenReady = false;
                    musicButtonUpdateState(true);
                }
            },
            'onStateChange': function(event){
                if (event.data === 0) {
                    musicButtonUpdateState(false);
                }
            }
        }
    });
}

/* ---------- Music toggle button ---------- */
const musicBtn = document.getElementById('musicButton');
musicBtn.addEventListener('click', toggleMusic);

function toggleMusic(){
    if (typeof ytPlayer !== 'undefined' && ytPlayerReady) {
        const state = ytPlayer.getPlayerState();
        if (state === 1) {
            ytPlayer.pauseVideo(); musicButtonUpdateState(false);
        } else {
            ytPlayer.playVideo(); musicButtonUpdateState(true);
        }
    } else {
        initYouTubePlayer();
        playWhenReady = true;
        musicButtonUpdateState(true, '...Loading');
    }
}

function musicButtonUpdateState(isPlaying, overrideText){
    if (overrideText) {
        musicBtn.textContent = '‚è≥ ' + overrideText;
        return;
    }
    musicBtn.textContent = isPlaying ? '‚è∏Ô∏è Pause Music' : '‚ñ∂Ô∏è Play Music';
}

/* ---------- Init ---------- */
window.addEventListener('load', function(){
    updateTime();
    // keep compatibility: if legacy code calls handleQueryParams, it exists
    if (typeof handleQueryParams === 'function') handleQueryParams();
    initYouTubePlayer(); // kh·ªüi ƒë·ªông s·ªõm (kh√¥ng autoplay) ƒë·ªÉ s·∫µn s√†ng khi ng∆∞·ªùi d√πng copy
});
</script>
</body>
</html>
